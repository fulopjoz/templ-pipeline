"""
TEMPL Pipeline Streamlit UI

This module provides a web-based user interface for the TEMPL pipeline using Streamlit.
It allows users to:
1. Generate protein embeddings
2. Find similar templates
3. Generate poses using the pipeline
4. Visualize and analyze results
"""

import os
import io
import sys
import tempfile
from pathlib import Path
import numpy as np
from typing import Dict, List, Optional, Tuple, Any, Union
import uuid
import gzip
import logging
import json
import base64
import time

import streamlit as st
from streamlit import session_state as ss
from rdkit import Chem
from rdkit.Chem import AllChem, Draw, rdShapeHelpers
import py3Dmol
from rdkit import RDLogger
RDLogger.DisableLog('rdApp.*')

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger("streamlit_app")

# Import stmol for alternative 3D visualization
try:
    from stmol import showmol
    STMOL_AVAILABLE = True
except ImportError:
    STMOL_AVAILABLE = False
    st.warning("stmol package not found. Installing stmol will provide an alternative 3D visualization method.")

# Add parent directory to path to ensure package is found
# This is needed when the script is run directly
current_file_path = Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent  # mcs directory
sys.path.insert(0, str(project_root))

# Import pipeline modules
try:
    from templ_pipeline.core.embedding import (
        EmbeddingManager, 
        get_protein_embedding,
        get_embedding,
        get_sample_pdb_ids,
        is_pdb_id_in_database,
        _resolve_embedding_path,
        select_templates
    )
    from templ_pipeline.core.utils import find_pocket_chains, find_pdbbind_paths
    from templ_pipeline.core.mcs import (
        find_mcs, 
        generate_conformers, 
        transform_ligand,
        prepare_mol
    )
    from templ_pipeline.core.scoring import select_best as scoring_select_best
except ImportError:
    # Try with a different path configuration
    try:
        # Add parent directory to path if running as standalone
        parent_dir = str(Path(__file__).parent.parent)
        if parent_dir not in sys.path:
            sys.path.append(parent_dir)
        
        # Try importing again
        from templ_pipeline.core.embedding import (
            EmbeddingManager, 
            get_protein_embedding,
            get_embedding,
            get_sample_pdb_ids,
            is_pdb_id_in_database,
            _resolve_embedding_path,
            select_templates
        )
        from templ_pipeline.core.utils import find_pocket_chains, find_pdbbind_paths
        from templ_pipeline.core.mcs import (
            find_mcs, 
            generate_conformers, 
            transform_ligand,
            prepare_mol
        )
        from templ_pipeline.core.scoring import select_best as scoring_select_best
    except ImportError as e:
        st.error(f"Failed to import TEMPL pipeline modules: {str(e)}")
        st.info("Please run this application from the project root directory using: python -m templ_pipeline.ui.streamlit_app")
        st.stop()

# Configure page
st.set_page_config(
    page_title="TEMPL Pipeline",
    page_icon="🧪",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Initialize session state for persistent data
if "protein_embedding" not in ss:
    ss.protein_embedding = None
if "template_results" not in ss:
    ss.template_results = None
if "query_mol" not in ss:
    ss.query_mol = None
if "template_mol" not in ss:
    ss.template_mol = None
if "conformers" not in ss:
    ss.conformers = None
if "poses" not in ss:
    ss.poses = {}
if "protein_file" not in ss:
    ss.protein_file = None
if "protein_pdb_id" not in ss:
    ss.protein_pdb_id = None
if "pocket_chains" not in ss:
    ss.pocket_chains = []
if "mcs_indices" not in ss:
    ss.mcs_indices = {}
if "crystal_mol" not in ss:
    ss.crystal_mol = None

# Helper functions
def display_molecule(mol, width=600, height=400):
    """Display an RDKit molecule using SVG.
    
    For 3D molecules, converts to 2D representation before displaying.
    Uses RDKit's MolToImage with enhanced 2D drawing options.
    """
    if mol is None:
        return
        
    # Make a copy of the molecule and remove Hs
    mol_copy = Chem.RemoveHs(Chem.Mol(mol))
    
    # If molecule has 3D coordinates, convert to 2D
    if mol_copy.GetNumConformers() > 0 and mol_copy.GetConformer().Is3D():
        mol_copy.Compute2DCoords()
    
    # Generate 2D depiction with enhanced options
    img = Draw.MolToImage(
        mol_copy,
        size=(width, height),
        kekulize=True,
        wedgeBonds=True,
        fitImage=True,
        highlightAtoms=[],  # No highlighting by default
        highlightBonds=[]   # No highlighting by default
    )
    st.image(img)

def initialize_3d_viewer(width=600, height=400):
    """Initialize the 3D molecule viewer using py3Dmol.
    
    Args:
        width: Viewer width in pixels
        height: Viewer height in pixels
        
    Returns:
        Initialized py3Dmol view object
    """
    try:
        # Create an empty py3Dmol view object
        viewer = py3Dmol.view(width=width, height=height)
        return viewer
    except Exception as e:
        st.error(f"Error initializing py3Dmol viewer: {str(e)}")
        st.info("Please make sure py3Dmol is installed: pip install py3Dmol")
        return None

def read_pdb_file(file):
    """Read a PDB file from streamlit uploaded file."""
    with tempfile.NamedTemporaryFile(suffix=".pdb", delete=False) as fp:
        fp.write(file.getvalue())
        pdb_path = fp.name
    return pdb_path

def display_3d_molecule(mol, viewer, style="stick", color_scheme="element", 
                      show_protein=False, protein_file=None, show_surface=False, pocket_chains=None,
                      highlight_mcs=False, mcs_indices=None):
    """Add a molecule to the 3D viewer with advanced options.
    
    Args:
        mol: RDKit molecule to display
        viewer: py3Dmol viewer object
        style: Display style (stick, ball+stick, spacefill, line)
        color_scheme: Color scheme to use
        show_protein: Whether to display protein structure
        protein_file: Path to protein PDB file
        show_surface: Whether to show protein surface
        pocket_chains: List of chain IDs that form the binding pocket
        highlight_mcs: Whether to highlight the maximum common substructure
        mcs_indices: List of atom indices in the MCS
    
    Returns:
        HTML component with the 3D visualization
    """
    # Try using stmol first if it's available and no protein is needed
    if STMOL_AVAILABLE and not show_protein:
        try:
            # For simple molecule display without protein, stmol is more reliable
            return display_molecule_stmol(mol, style=style)
        except Exception as e:
            st.warning(f"Stmol visualization failed, falling back to py3Dmol: {str(e)}")
            # Fall back to regular py3Dmol approach
            pass
    
    # Regular py3Dmol approach    
    try:
        unique_id = uuid.uuid4().hex[:8]
        
        # Generate and optimize conformer
        AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
        AllChem.MMFFOptimizeMolecule(mol)
        
        # Convert mol to block format
        mol_block = Chem.rdmolfiles.MolToMolBlock(mol, kekulize=True)
        
        # Add protein if requested
        if show_protein and protein_file:
            with open(protein_file, 'r') as f:
                pdb_data = f.read()
            
            viewer.addModel(pdb_data, 'pdb')
            
            # Style protein - default to cartoon with white color
            if pocket_chains:
                # Style specific pocket chains differently
                viewer.setStyle({'chain': pocket_chains}, 
                              {'cartoon': {'color': 'lightblue'}})
                # Style the rest of the protein
                viewer.setStyle({'chain': pocket_chains, 'invert': True}, 
                              {'cartoon': {'color': 'white'}})
            else:
                # Style all of the protein
                viewer.setStyle({'model': 0}, {'cartoon': {'color': 'white'}})
            
            if show_surface:
                viewer.addSurface(py3Dmol.VDW, {'opacity': 0.6, 'color': 'white'}, 
                                {'model': 0})
        
        # Add the molecule
        model_index = 1 if show_protein else 0
        viewer.addModel(mol_block, 'mol')
        
        # Set the style for the molecule
        style_options = {}
        
        if style == "stick" or style == "licorice":
            style_options = {"stick": {}}
        elif style == "ball+stick":
            style_options = {"stick": {}, "sphere": {"scale": 0.3}}
        elif style == "spacefill" or style == "sphere":
            style_options = {"sphere": {}}
        elif style == "line":
            style_options = {"line": {}}
        elif style == "cartoon":
            style_options = {"cartoon": {}}
        else:
            # Default to stick if unknown style
            style_options = {"stick": {}}
        
        # Style molecule
        viewer.setStyle({'model': model_index}, style_options)
        
        # Highlight MCS atoms if specified
        if highlight_mcs and mcs_indices:
            # Create a selection object for MCS atoms
            mcs_selection = {'model': model_index, 'atom': list(map(int, mcs_indices))}
            viewer.setStyle(mcs_selection, {'stick': {'color': 'green', 'radius': 0.5}})
        
        # Set viewport
        viewer.zoomTo()
        
        # Show the viewer
        viewer.setBackgroundColor('white')
        
        # Convert to HTML and display in Streamlit
        html = viewer.render()
        
        # Simple approach - don't use a key parameter which causes errors
        return st.components.v1.html(html, height=400, width=700)
        
    except Exception as e:
        st.error(f"Error displaying 3D molecule: {str(e)}")
        import traceback
        st.error(traceback.format_exc())
        return None

def show_multi_view(mols, titles, protein_file=None, pocket_chains=None, mcs_indices=None, width=350, height=350):
    """Show multiple molecules in a grid layout using py3Dmol.
    
    Args:
        mols: List of RDKit molecules to display
        titles: List of titles for each molecule
        protein_file: Optional path to protein PDB file to display with each molecule
        pocket_chains: Optional list of pocket chain IDs
        mcs_indices: Optional dictionary mapping mol indices to MCS atom indices
        width: Width of each viewer
        height: Height of each viewer
    """
    # Create columns based on number of molecules
    n_mols = len(mols)
    if n_mols == 0:
        return
        
    # Calculate grid size
    n_cols = min(3, n_mols)
    n_rows = (n_mols + n_cols - 1) // n_cols
    
    # Create columns for each row
    for row in range(n_rows):
        cols = st.columns(n_cols)
        for col in range(n_cols):
            idx = row * n_cols + col
            if idx < n_mols:
                with cols[col]:
                    st.subheader(titles[idx])
                    mol = mols[idx]
                    if mol is not None:
                        # Determine if we need to highlight MCS for this molecule
                        highlight_indices = None
                        if mcs_indices is not None and idx in mcs_indices:
                            highlight_indices = mcs_indices[idx]
                        
                        # Display 2D structure first for reference
                        display_molecule(mol, width=width, height=height)
                        
                        # Create a container with a unique key for this molecule
                        mol_container = st.container()
                        with mol_container:
                            # Create a new py3Dmol viewer for this molecule with a unique ID
                            unique_id = f"mol_{idx}_{uuid.uuid4().hex[:6]}"
                            viewer = py3Dmol.view(width=width, height=height)
                            if viewer:
                                display_3d_molecule(
                                    mol, 
                                    viewer, 
                                    show_protein=(protein_file is not None), 
                                    protein_file=protein_file,
                                    pocket_chains=pocket_chains,
                                    highlight_mcs=(highlight_indices is not None),
                                    mcs_indices=highlight_indices
                                )
                    else:
                        st.write("No molecule to display")

def multi_mol_tab_view(mols_dict, protein_file=None, pocket_chains=None, mcs_dict=None):
    """Display molecules in a tabbed interface using py3Dmol for 3D visualization.
    
    Args:
        mols_dict: Dictionary mapping tab names to lists of (molecule, title) tuples
        protein_file: Optional path to protein PDB file
        pocket_chains: Optional list of pocket chain IDs
        mcs_dict: Optional dictionary mapping (tab_name, mol_idx) to MCS atom indices
    """
    # Create tabs
    tabs = st.tabs(list(mols_dict.keys()))
    
    # Fill each tab
    for i, (tab_name, mol_list) in enumerate(mols_dict.items()):
        with tabs[i]:
            if not mol_list:
                st.write("No molecules to display")
                continue
                
            # Extract molecules and titles
            mols = [m for m, _ in mol_list]
            titles = [t for _, t in mol_list]
            
            # Extract MCS indices for this tab if available
            tab_mcs_indices = None
            if mcs_dict is not None:
                tab_mcs_indices = {}
                for (t_name, mol_idx), indices in mcs_dict.items():
                    if t_name == tab_name:
                        tab_mcs_indices[mol_idx] = indices
            
            # Display molecules using our updated show_multi_view function
            show_multi_view(mols, titles, protein_file, pocket_chains, tab_mcs_indices)

def render_results_tab(tab):
    """Render the results tab with advanced visualization options."""
    with tab:
        st.header("TEMPL Results")
        
        # Check if we have results to display
        if not ss.poses or len(ss.poses) == 0:
            st.info("No results to display. Please generate poses first.")
            return
        
        # Options for visualization
        with st.expander("Visualization Options", expanded=True):
            col1, col2, col3 = st.columns(3)
            
            with col1:
                show_protein = st.checkbox("Show Protein", value=True, 
                                         help="Display protein structure with poses")
                show_pocket = st.checkbox("Highlight Pocket", value=True,
                                        help="Highlight binding pocket chains")
                show_surface = st.checkbox("Show Surface", value=False,
                                         help="Show protein surface")
            
            with col2:
                highlight_mcs = st.checkbox("Highlight MCS", value=True,
                                          help="Highlight atoms in the maximum common substructure")
                viewer_style = st.selectbox("Ligand Style", 
                                           ["stick", "ball+stick", "sphere", "line", "cartoon"],
                                           index=0,
                                           help="Visual representation of the ligand molecule")
            
            with col3:
                view_mode = st.radio("View Mode",
                                    ["Tabbed", "Grid", "Detailed"],
                                    index=0,
                                    help="Choose how to organize multiple views")
        
        # Gather data for visualization
        protein_file = None
        pocket_chains = []
        
        # Get protein file path
        if show_protein:
            if "protein_file" in ss and ss.protein_file:
                protein_file = ss.protein_file
            elif "protein_pdb_id" in ss and ss.protein_pdb_id:
                # Try to locate protein PDB file from PDBbind
                from templ_pipeline.core.utils import find_pdbbind_paths
                paths = find_pdbbind_paths(ss.protein_pdb_id)
                if paths["protein"]:
                    protein_file = paths["protein"]
                    st.success(f"Found protein file: {protein_file}")
                else:
                    st.warning(f"Could not locate protein file for PDB ID: {ss.protein_pdb_id}")
        
        # Get pocket chains if needed
        if show_pocket and protein_file:
            if "pocket_chains" in ss and ss.pocket_chains:
                pocket_chains = ss.pocket_chains
            else:
                # Try to detect pocket chains
                try:
                    from templ_pipeline.core.utils import find_pocket_chains
                    
                    # Check if we have a template or crystal ligand to use
                    ligand_file = None
                    if "template_mol" in ss and ss.template_mol:
                        # Save template to temp file
                        with tempfile.NamedTemporaryFile(suffix=".sdf", delete=False) as f:
                            writer = Chem.SDWriter(f.name)
                            writer.write(ss.template_mol)
                            writer.close()
                            ligand_file = f.name
                    
                    # Find pocket chains
                    if ligand_file:
                        pocket_chains = find_pocket_chains(protein_file, ligand_file)
                        ss.pocket_chains = pocket_chains
                        st.success(f"Detected pocket chains: {', '.join(pocket_chains)}")
                    else:
                        st.warning("No ligand available to detect pocket chains.")
                except Exception as e:
                    st.error(f"Error detecting pocket chains: {str(e)}")
        
        # Organize molecules for visualization
        if view_mode == "Tabbed":
            # Create dictionary for tabbed view
            mols_dict = {
                "Best Poses": [],
                "All Conformers": [],
                "Template & Crystal": []
            }
            
            # Add best poses
            for metric, pose in ss.poses.items():
                if pose:
                    mols_dict["Best Poses"].append((pose, f"{metric.capitalize()} Pose"))
            
            # Add conformers if available
            if "conformers" in ss and ss.conformers:
                conf_mol = ss.conformers
                for i in range(min(10, conf_mol.GetNumConformers())):
                    # Extract single conformer mol
                    single_conf = Chem.Mol(conf_mol)
                    single_conf.RemoveAllConformers()
                    single_conf.AddConformer(Chem.Conformer(conf_mol.GetConformer(i)))
                    mols_dict["All Conformers"].append((single_conf, f"Conformer {i+1}"))
            
            # Add template and crystal if available
            if "template_mol" in ss and ss.template_mol:
                mols_dict["Template & Crystal"].append((ss.template_mol, "Template"))
            
            if "crystal_mol" in ss and ss.crystal_mol:
                mols_dict["Template & Crystal"].append((ss.crystal_mol, "Crystal Ligand"))
            
            # Create MCS dictionary for highlighting
            mcs_dict = {}
            if highlight_mcs and "mcs_indices" in ss and ss.mcs_indices:
                # Format depends on how MCS indices are stored in session state
                # Assuming a dictionary mapping pose keys to atom indices
                mcs_idx = 0
                for metric, indices in ss.mcs_indices.items():
                    if indices:
                        mcs_dict[("Best Poses", mcs_idx)] = indices
                        mcs_idx += 1
            
            # Display tabbed view
            multi_mol_tab_view(mols_dict, protein_file, pocket_chains, mcs_dict)
        
        elif view_mode == "Grid":
            # For grid view, we'll show all molecules in a single grid
            mols = []
            titles = []
            
            # Add best poses
            for metric, pose in ss.poses.items():
                if pose:
                    mols.append(pose)
                    titles.append(f"{metric.capitalize()} Pose")
            
            # Add template and crystal if available
            if "template_mol" in ss and ss.template_mol:
                mols.append(ss.template_mol)
                titles.append("Template")
            
            if "crystal_mol" in ss and ss.crystal_mol:
                mols.append(ss.crystal_mol)
                titles.append("Crystal")
            
            # Create MCS dictionary for highlighting
            mcs_indices = {}
            if highlight_mcs and "mcs_indices" in ss and ss.mcs_indices:
                # Adapt to grid view indexing
                idx = 0
                for metric, indices in ss.mcs_indices.items():
                    if indices:
                        mcs_indices[idx] = indices
                        idx += 1
            
            # Display grid view
            show_multi_view(mols, titles, protein_file, pocket_chains, mcs_indices)
            
        else:  # Detailed view
            # For detailed view, we'll focus on one molecule at a time with more info
            st.subheader("Select View")
            view_options = []
            
            # Add pose options
            for metric in ss.poses:
                view_options.append(f"{metric.capitalize()} Pose")
            
            # Add template and crystal options
            if "template_mol" in ss and ss.template_mol:
                view_options.append("Template")
            
            if "crystal_mol" in ss and ss.crystal_mol:
                view_options.append("Crystal Ligand")
            
            # Let user select which one to view
            selected_view = st.selectbox("Select molecule to view", view_options)
            
            # Display the selected molecule
            if selected_view:
                mol = None
                mcs_indices_to_show = None
                
                # Get the selected molecule
                if selected_view.endswith("Pose"):
                    metric = selected_view.split()[0].lower()
                    if metric in ss.poses:
                        mol = ss.poses[metric]
                        # Get MCS indices if available
                        if highlight_mcs and "mcs_indices" in ss and metric in ss.mcs_indices:
                            mcs_indices_to_show = ss.mcs_indices[metric]
                
                elif selected_view == "Template" and "template_mol" in ss:
                    mol = ss.template_mol
                
                elif selected_view == "Crystal Ligand" and "crystal_mol" in ss:
                    mol = ss.crystal_mol
                
                # Display molecule with details
                if mol:
                    col1, col2 = st.columns([2, 1])
                    
                    with col1:
                        # Display 3D view
                        st.write("3D Structure:")
                        viewer = initialize_3d_viewer(width=600, height=500)
                        if viewer:
                            display_3d_molecule(
                                mol,
                                viewer, 
                                style=viewer_style,
                                show_protein=show_protein,
                                protein_file=protein_file,
                                show_surface=show_surface,
                                pocket_chains=pocket_chains,
                                highlight_mcs=highlight_mcs and mcs_indices_to_show is not None,
                                mcs_indices=mcs_indices_to_show
                            )
                    
                    with col2:
                        # Display details
                        st.subheader("Details")
                        
                        # Show 2D structure
                        st.write("2D Structure:")
                        display_molecule(mol, width=300, height=200)
                        
                        # Display properties if available
                        st.write("Properties:")
                        for prop in mol.GetPropNames():
                            value = mol.GetProp(prop)
                            if prop == "_Name":
                                st.write(f"Name: {value}")
                            elif prop.endswith("_score"):
                                st.write(f"{prop.replace('_score', '').title()} Score: {value}")
                            elif prop == "rmsd_to_crystal":
                                st.write(f"**RMSD to Crystal: {value} Å**")
                            elif prop == "embedding_similarity":
                                st.write(f"Template Similarity: {value}")
                            elif prop == "template_pdb":
                                st.write(f"Template PDB: {value}")
                        
                        # Display atom/bond counts
                        st.write(f"Atoms: {mol.GetNumAtoms()}")
                        st.write(f"Bonds: {mol.GetNumBonds()}")
                        
                        if selected_view.endswith("Pose"):
                            # Option to download this pose
                            sdf_string = Chem.MolToMolBlock(mol)
                            st.download_button(
                                label="Download SDF",
                                data=sdf_string,
                                file_name=f"{selected_view.replace(' ', '_').lower()}.sdf",
                                mime="chemical/x-mdl-sdfile"
                            )
        
        # Add option to download all results
        st.subheader("Download All Results")
        
        # Combine all molecules into a single SDF
        combined_sdf = io.StringIO()
        writer = Chem.SDWriter(combined_sdf)
        
        # Add all poses
        for metric, pose in ss.poses.items():
            if pose:
                writer.write(pose)
        
        # Add template and crystal if available
        if "template_mol" in ss and ss.template_mol:
            writer.write(ss.template_mol)
        
        if "crystal_mol" in ss and ss.crystal_mol:
            writer.write(ss.crystal_mol)
            
        writer.close()
        
        # Provide download button
        st.download_button(
            label="Download All as SDF",
            data=combined_sdf.getvalue(),
            file_name="templ_results.sdf",
            mime="chemical/x-mdl-sdfile"
        )

def process_pose_generation(tab, template_mols, query_mol, n_conformers, n_workers):
    """Process the pose generation tab functionality."""
    with tab:
        st.header("Pose Generation")
        
        # Validate input data
        if not template_mols:
            st.warning("No template molecules available. Please go to the Template Finding tab and find templates first.")
            st.info("In the Template Finding tab, you need to:")
            st.info("1. Generate a protein embedding")
            st.info("2. Find similar templates")
            st.info("3. Select templates to use")
            return
            
        if not query_mol:
            st.warning("No query molecule available. Please go to the Template Finding tab and upload a query molecule.")
            return
        
        # Template selection
        st.subheader("Template Selection")
        st.write("Select template to use")
        
        if template_mols:
            # Create dropdown with template names
            template_names = []
            for mol in template_mols:
                if mol.HasProp("_Name"):
                    template_names.append(mol.GetProp("_Name"))
                else:
                    template_names.append("Unknown Template")
            
            selected_template = st.selectbox("Select template to use", template_names)
            
            # Find the selected template
            template_mol = None
            for mol in template_mols:
                if mol.HasProp("_Name") and mol.GetProp("_Name") == selected_template:
                    template_mol = mol
                    break
            
            if not template_mol and template_mols:
                template_mol = template_mols[0]
            
            # Store template molecule in session state
            ss.template_mol = template_mol
            
            # Display template molecule
            st.write("Template Molecule")
            st.write(f"Name: {selected_template}")
            
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"Atoms: {template_mol.GetNumAtoms()}")
                st.write(f"Bonds: {template_mol.GetNumBonds()}")
            
            # Display template molecule
            display_molecule_stmol(template_mol)
        
        # Display query molecule
        st.subheader("Query Molecule")
        col1, col2 = st.columns(2)
        with col1:
            st.write(f"Atoms: {query_mol.GetNumAtoms()}")
            st.write(f"Bonds: {query_mol.GetNumBonds()}")
        
        # Display query molecule
        display_molecule_stmol(query_mol)
        
        # Display MCS if already calculated
        if "mcs_indices" in ss and selected_template in ss.mcs_indices:
            st.subheader("Maximum Common Substructure")
            st.write(f"Found {len(ss.mcs_indices[selected_template])} atoms in common")
            
            # Highlight MCS in query and template
            # (This would require a more complex visualization)
        else:
            # Show button to generate conformers
            st.subheader("Step 1: Generate Conformers")
            st.write("Generate conformers constrained by the selected template")
            
            # Generate conformer parameters
            n_confs = st.slider(
                "Number of Conformers", 
                min_value=10, 
                max_value=1000, 
                value=n_conformers, 
                step=10
            )
            
            n_workers_local = st.slider(
                "Number of Workers", 
                min_value=1, 
                max_value=24, 
                value=n_workers, 
                step=1
            )
            
            # Generate conformers button
            generate_button = st.button("Generate Conformers", use_container_width=True)
            
            if generate_button:
                with st.spinner("Generating conformers..."):
                    try:
                        # Find MCS and generate conformers
                        conformers, mcs_idx = generate_conformers(
                            query_mol, 
                            [template_mol], 
                            n_confs, 
                            n_workers_local
                        )
                        
                        if conformers and conformers.GetNumConformers() > 0:
                            # Store conformers in session state
                            ss.conformers = conformers
                            
                            # Store MCS indices
                            if selected_template not in ss.mcs_indices:
                                ss.mcs_indices = {}
                            ss.mcs_indices[selected_template] = mcs_idx
                            
                            # Success message
                            st.success(f"Successfully generated {conformers.GetNumConformers()} conformers!")
                            
                            # Display first conformer
                            st.write("First Conformer:")
                            display_molecule_stmol(conformers)
                        else:
                            st.error("Failed to generate conformers. No valid conformers were produced.")
                            
                            # Provide troubleshooting guidance
                            with st.expander("Troubleshooting Tips", expanded=True):
                                st.write("### Why Conformer Generation Failed")
                                st.write("The most common reason for this error is that the template and query molecule are too dissimilar, making it difficult to find a good Maximum Common Substructure (MCS).")
                                
                                st.write("### Template Molecule")
                                col1, col2 = st.columns(2)
                                with col1:
                                    st.write(f"Name: {selected_template}")
                                    st.write(f"Atoms: {template_mol.GetNumAtoms()}")
                                    st.write(f"Bonds: {template_mol.GetNumBonds()}")
                                
                                display_molecule_stmol(template_mol)
                                
                                st.write("### Query Molecule")
                                col1, col2 = st.columns(2)
                                with col1:
                                    st.write(f"Name: {'Unknown' if not query_mol.HasProp('_Name') else query_mol.GetProp('_Name')}")
                                    st.write(f"Atoms: {query_mol.GetNumAtoms()}")
                                    st.write(f"Bonds: {query_mol.GetNumBonds()}")
                                
                                display_molecule_stmol(query_mol)
                                
                                st.write("### Suggestions")
                                st.write("1. **Try a different template** - Select another template that may be more similar to your query molecule.")
                                st.write("2. **Simplify your molecules** - Try using simpler variations of your molecules with fewer complex features.")
                                st.write("3. **Check stereochemistry** - Complex stereochemistry can sometimes cause problems with MCS searches.")
                                st.write("4. **Examine available templates** - Look at the similarity scores to find better matching templates.")
                                
                                if len(template_mols) > 1:
                                    st.write("### Alternative Templates Available")
                                    for i, mol in enumerate(template_mols[:3]):  # Show top 3 alternatives
                                        if mol != template_mol and mol.HasProp("_Name"):
                                            st.write(f"- {mol.GetProp('_Name')}")
                            
                            return
                    except Exception as e:
                        st.error(f"Error generating conformers: {str(e)}")
                        # Log the full traceback
                        import traceback
                        logger.error(f"Conformer generation error: {str(e)}\n{traceback.format_exc()}")
                        
                        # Show traceback for debugging
                        with st.expander("Error Details", expanded=False):
                            st.code(traceback.format_exc(), language="python")
                    except Exception as e:
                        st.error(f"Unexpected error: {str(e)}")
                        # Log the full traceback
                        import traceback
                        logger.error(f"Unexpected error: {str(e)}\n{traceback.format_exc()}")
    
        # Proceed to pose selection if conformers are available
        if "conformers" in ss and ss.conformers:
            st.subheader("Step 2: Pose Selection")
            st.write("Score and select the best poses based on different criteria")
            
            # Button to score poses
            score_poses_button = st.button("Score and Select Poses", use_container_width=True)
            
            if score_poses_button:
                with st.spinner("Scoring poses..."):
                    try:
                        # Use stored template molecule from session state
                        template_mol = ss.template_mol
                        
                        if not template_mol:
                            st.error("Template molecule not found. Please generate conformers first.")
                            return
                        
                        # Score and align
                        conf_mol = ss.conformers
                        
                        # Get number of conformers
                        n_confs = conf_mol.GetNumConformers()
                        st.info(f"Scoring {n_confs} conformers...")
                        
                        # Score using different methods
                        # Use the properly imported select_best function
                        results = scoring_select_best(conf_mol, template_mol, n_workers=n_workers_local)
                        
                        if results:
                            # Store results
                            ss.poses = results
                            
                            # Display results
                            st.success("Successfully scored and selected poses!")
                            
                            # Create a table of scores
                            score_table = {}
                            for method, (mol, scores) in results.items():
                                for metric, value in scores.items():
                                    if metric not in score_table:
                                        score_table[metric] = {}
                                    score_table[metric][method] = f"{value:.4f}"
                            
                            # Display table
                            st.write("### Scoring Results")
                            st.table(score_table)
                            
                            # Display best pose
                            st.write("### Best Overall Pose")
                            best_mol, _ = results.get("combo", (None, None))
                            
                            if best_mol:
                                col1, col2 = st.columns(2)
                                with col1:
                                    st.write("2D Structure:")
                                    display_molecule(best_mol)
                                with col2:
                                    st.write("3D Structure:")
                                    viewer = initialize_3d_viewer(width=350, height=300)
                                    if viewer:
                                        display_3d_molecule(best_mol, viewer)
                        else:
                            st.error("Failed to score and select poses.")
                    except Exception as e:
                        st.error(f"Error scoring poses: {str(e)}")
                        # Log the error
                        logger.error(f"Error scoring poses: {str(e)}\n{traceback.format_exc()}")
            
            # Option to load a reference crystal structure for comparison
            st.subheader("Step 3 (Optional): Load Reference Crystal Structure")
            crystal_file = st.file_uploader(
                "Upload Crystal Ligand SDF",
                type=["sdf", "mol"],
                help="Upload known crystal structure for comparison"
            )
            
            if crystal_file:
                try:
                    # Read crystal structure
                    crystal_bytes = crystal_file.read()
                    crystal_supplier = Chem.SDMolSupplier()
                    crystal_supplier.SetData(crystal_bytes)
                    
                    crystal_mol = None
                    for mol in crystal_supplier:
                        if mol:
                            crystal_mol = mol
                            break
                    
                    if crystal_mol:
                        # Store crystal structure
                        ss.crystal_mol = crystal_mol
                        
                        # Calculate RMSD to crystal if poses are available
                        if "poses" in ss and ss.poses:
                            st.info("Calculating RMSD to crystal structure...")
                            
                            for method, (pose_mol, scores) in ss.poses.items():
                                # Calculate RMSD
                                try:
                                    # Use MCS-based alignment for a fair comparison
                                    _, rmsd = Chem.rdMolAlign.GetO3AForProbeConfs(
                                        pose_mol, 
                                        crystal_mol,
                                        numConfs=1
                                    )
                                    
                                    if rmsd:
                                        # Store RMSD value as a property on the molecule
                                        pose_mol.SetProp("rmsd_to_crystal", f"{rmsd[0]:.2f}")
                                        
                                        # Update session state
                                        ss.poses[method] = (pose_mol, scores)
                                except Exception as e:
                                    st.warning(f"Could not calculate RMSD for {method} pose: {str(e)}")
                                    logger.warning(f"Could not calculate RMSD for {method} pose: {str(e)}")
                            
                            # Display RMSD results
                            st.success("RMSD calculation complete!")
                            
                            # Show RMSD table
                            rmsd_table = {"RMSD to Crystal (Å)": {}}
                            for method, (pose_mol, _) in ss.poses.items():
                                if pose_mol.HasProp("rmsd_to_crystal"):
                                    rmsd_table["RMSD to Crystal (Å)"][method] = pose_mol.GetProp("rmsd_to_crystal")
                            
                            st.table(rmsd_table)
                    else:
                        st.error("Could not read crystal structure from file.")
                except Exception as e:
                    st.error(f"Error processing crystal structure: {str(e)}")
                    logger.error(f"Error processing crystal structure: {str(e)}\n{traceback.format_exc()}")
        
        # Provide navigation guidance
        try:
            if "poses" in ss and ss.poses:
                st.info("Proceed to the Results tab to view and analyze your poses.")
                with st.expander("Advanced Options", expanded=False):
                    # Option to clear results
                    if st.button("Clear Results", use_container_width=True):
                        ss.conformers = None
                        ss.poses = {}
                        ss.crystal_mol = None
                        ss.template_mol = None
                        ss.mcs_indices = {}
                        st.success("Results cleared!")
                        st.experimental_rerun()
        except Exception as e:
            st.error(f"Error in interface rendering: {str(e)}")
            logger.error(f"Error in interface rendering: {str(e)}\n{traceback.format_exc()}")

def display_molecule_stmol(mol, height=400, width=700, style="stick"):
    """Display a molecule using stmol for 3D visualization
    
    Args:
        mol: RDKit molecule to display
        height: Height of the viewer
        width: Width of the viewer
        style: Style to use for the molecule
    
    Returns:
        The stmol viewer
    """
    if not STMOL_AVAILABLE:
        st.error("stmol is not available. Please install with: pip install stmol")
        return None
    
    if mol is None:
        return None
    
    try:
        # Convert style names if needed
        if style == "spacefill":
            style = "sphere"
        elif style == "licorice":
            style = "stick"
            
        # Create a py3Dmol view
        view = py3Dmol.view(width=width, height=height)
        
        # Add the molecule
        mol_block = Chem.MolToMolBlock(mol)
        view.addModel(mol_block, 'mol')
        
        # Set the style based on parameters
        style_options = {}
        
        if style == "stick":
            style_options = {"stick": {}}
        elif style == "ball+stick":
            style_options = {"stick": {}, "sphere": {"scale": 0.3}}
        elif style == "sphere":
            style_options = {"sphere": {}}
        elif style == "line":
            style_options = {"line": {}}
        elif style == "cartoon":
            style_options = {"cartoon": {}}
        else:
            # Default to stick if unknown style
            style_options = {"stick": {}}
            
        view.setStyle({}, style_options)
        view.setBackgroundColor('white')
        view.zoomTo()
        
        # Show the molecule using stmol
        return showmol(view, height=height, width=width)
    
    except Exception as e:
        st.error(f"Error displaying molecule with stmol: {str(e)}")
        return None

def load_templates_from_processed_sdf(template_pdbs, gz_path="templ_pipeline/data/ligands/processed_ligands_new.sdf.gz"):
    """Load template molecules from the pre-processed SDF.gz file.
    
    This function implements the template molecule loading process as used in true_mcs_pipeline.py,
    which loads 3D molecule structures from a pre-processed compressed SDF file. Each molecule
    in the file contains a valid 3D conformer that can be used for MCS-based template alignment.
    
    The function attempts to find the compressed SDF file in several locations:
    1. The path explicitly provided
    2. Relative to the current working directory
    3. At the expected absolute path in the templ_pipeline directory
    4. At the expected absolute path in the mcs_bench directory
    
    Args:
        template_pdbs: List of PDB IDs to load
        gz_path: Path to the compressed SDF file
        
    Returns:
        List of loaded template molecules with 3D conformers
    """
    # Check if a custom path is provided in session state
    if 'custom_sdf_path' in st.session_state and st.session_state.custom_sdf_path:
        gz_path = st.session_state.custom_sdf_path
        st.info(f"Using custom SDF path from settings: {gz_path}")
    
    # Normalize template PDB IDs to lowercase for consistent matching
    template_pdbs_lower = [pdb_id.lower() for pdb_id in template_pdbs]
    
    # Try multiple possible paths for the file
    possible_paths = [
        gz_path,  # Try the path as provided
        os.path.join(os.getcwd(), gz_path),  # Try relative to current directory
        "/home/ubuntu/mcs/templ_pipeline/data/ligands/processed_ligands_new.sdf.gz",  # Try absolute path
        "/home/ubuntu/mcs/mcs_bench/data/processed_ligands_new.sdf.gz"  # Try the path from true_mcs_pipeline.py
    ]
    
    file_path = None
    for path in possible_paths:
        if os.path.exists(path):
            file_path = path
            break
    
    if not file_path:
        st.error(f"Processed ligands file not found in any of the expected locations")
        return []
    
    templates = []
    loaded_pdb_ids = set()
    missing_pdbs = set()
    template_diagnostics = {}  # Store diagnostics for each template
    
    try:
        st.info(f"Loading templates from: {file_path}")
        
        # First scan to collect molecule names
        pdb_id_map = {}  # Map to store different PDB ID forms found in the SDF
        with gzip.open(file_path, 'rb') as fh:
            for mol in Chem.ForwardSDMolSupplier(fh, removeHs=False, sanitize=False):
                if not mol or not mol.GetNumConformers():
                    continue
                
                # Get all possible PDB ID forms from molecule name
                if mol.HasProp("_Name"):
                    mol_name = mol.GetProp("_Name")
                    # Try different patterns for PDB IDs
                    possible_pdb_ids = [
                        mol_name[:4].lower(),  # First 4 chars lowercase
                        mol_name.lower().split('_')[0] if '_' in mol_name else '',  # Before first underscore
                    ]
                    
                    for possible_id in possible_pdb_ids:
                        if possible_id and len(possible_id) == 4:  # Valid PDB ID length
                            if possible_id not in pdb_id_map:
                                pdb_id_map[possible_id] = []
                            pdb_id_map[possible_id].append(mol_name)
        
        # Now open again to load actual molecules
        with gzip.open(file_path, 'rb') as fh:
            mol_count = 0 # For debugging
            for mol in Chem.ForwardSDMolSupplier(fh, removeHs=False, sanitize=False):
                mol_count += 1
                if not mol or not mol.GetNumConformers():
                    continue
                
                # Get PDB ID from molecule name
                if mol.HasProp("_Name"):
                    mol_name = mol.GetProp("_Name")
                    pdb_id = mol_name[:4].lower()  # PDB IDs are 4 characters
                    
                    # Check if this matches any requested template
                    if pdb_id in template_pdbs_lower and pdb_id not in loaded_pdb_ids:
                        # Validate the molecule before adding
                        valid_mol = True
                        diagnostics = {
                            "original_name": mol_name,
                            "atoms": mol.GetNumAtoms(),
                            "bonds": mol.GetNumBonds(),
                            "conformers": mol.GetNumConformers()
                        }
                        
                        # Check for minimal validity
                        if mol.GetNumAtoms() < 3 or mol.GetNumBonds() < 1:
                            valid_mol = False
                            diagnostics["valid"] = False
                            diagnostics["reason"] = f"Too few atoms ({mol.GetNumAtoms()}) or bonds ({mol.GetNumBonds()})"
                        elif mol.GetNumConformers() == 0:
                            valid_mol = False
                            diagnostics["valid"] = False
                            diagnostics["reason"] = "No conformers"
                        else:
                            # Try sanitizing a copy to check for chemistry problems
                            try:
                                mol_copy = Chem.Mol(mol)
                                Chem.SanitizeMol(mol_copy)
                                diagnostics["valid"] = True
                            except Exception as e:
                                valid_mol = False
                                diagnostics["valid"] = False
                                diagnostics["reason"] = f"Failed sanitization: {str(e)}"
                        
                        # Store the molecule if valid
                        if valid_mol:
                            # Ensure consistent naming - this helps with debugging and matching
                            mol.SetProp("_Name", pdb_id)
                            templates.append(mol)
                            loaded_pdb_ids.add(pdb_id)
                        
                        # Store diagnostics regardless
                        template_diagnostics[pdb_id] = diagnostics
        
        # Show additional debug info if debug mode is enabled
        if hasattr(st.session_state, 'debug_mode') and st.session_state.debug_mode:
            st.write(f"Total molecules processed from SDF: {mol_count}")
            st.write(f"Unique PDB IDs found in SDF: {len(pdb_id_map)}")
            with st.expander("Debug: PDB ID mapping"):
                st.write("Sample of PDB IDs found in SDF file:")
                st.json({k: v[:3] for k, v in list(pdb_id_map.items())[:10]})
        
        # Check what's missing and report it with diagnostics
        missing_pdbs = set(template_pdbs_lower) - loaded_pdb_ids
        if missing_pdbs:
            st.warning(f"Could not find template molecules for: {', '.join(missing_pdbs)}")
            
            # Check if any missing PDbs have close matches in the file
            for missing_pdb in missing_pdbs:
                st.error(f"Could not find ligand file for PDB ID: {missing_pdb}")
                
                # Check for partial matches in our scan results
                close_matches = []
                for key in pdb_id_map:
                    # Check for similar IDs (e.g. 1a2b vs 1A2B)
                    if key.lower()[:3] == missing_pdb.lower()[:3]:
                        close_matches.append((key, pdb_id_map[key]))
                
                if close_matches:
                    st.info(f"Close matches for {missing_pdb} in the SDF file: {', '.join([m[0] for m in close_matches])}")
        
        # If no real molecules were loaded, create basic placeholder templates with warnings
        if not templates and template_pdbs:
            st.warning("Could not load actual template molecules. Using placeholder molecules instead.")
            for pdb_id in template_pdbs:
                # Create a placeholder molecule - a single carbon atom
                placeholder = Chem.MolFromSmiles("C")
                if placeholder:
                    # This is just a dummy molecule with no real structure - flag it as a placeholder
                    placeholder.SetProp("_Name", pdb_id.lower())
                    placeholder.SetProp("_IsPlaceholder", "True")
                    # Don't generate conformers here - they'd be meaningless
                    templates.append(placeholder)
                    
                    # Store diagnostics for the placeholder
                    template_diagnostics[pdb_id.lower()] = {
                        "original_name": pdb_id,
                        "atoms": 1,
                        "bonds": 0,
                        "conformers": 0,
                        "valid": False,
                        "reason": "Placeholder molecule only - real template not found in SDF file"
                    }
                    
                    # Log a warning about the placeholder
                    st.info(f"Template {pdb_id}: {template_diagnostics[pdb_id.lower()]['atoms']} atoms, {template_diagnostics[pdb_id.lower()]['bonds']} bonds")
                    
                    # Add to session state for debugging
                    if 'template_diagnostics' not in st.session_state:
                        st.session_state.template_diagnostics = {}
                    st.session_state.template_diagnostics[pdb_id.lower()] = template_diagnostics[pdb_id.lower()]
        
        return templates
    except Exception as e:
        st.error(f"Error loading templates from processed SDF: {str(e)}")
        import traceback
        st.error(traceback.format_exc())
        return []

# Main application
def main():
    """Main Streamlit application."""
    st.title("TEMPL Pipeline")
    st.write("Template-based Protein Ligand pose prediction")
    
    # Set default embedding path from environment or default location
    DEFAULT_EMBEDDING_PATH = os.getenv("TEMPL_EMBEDDING_PATH", "data/embeddings/protein_embeddings_base.npz")
    ABSOLUTE_DEFAULT_PATH = "/home/ubuntu/mcs/templ_pipeline/data/embeddings/protein_embeddings_base.npz"
    
    # Initialize logging
    import logging
    logger = logging.getLogger("templ_pipeline")
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    
    # Initialize session state if needed
    if "embedding_path" not in st.session_state:
        if os.path.exists(ABSOLUTE_DEFAULT_PATH):
            st.session_state.embedding_path = ABSOLUTE_DEFAULT_PATH
            logger.info(f"Using absolute embedding path: {ABSOLUTE_DEFAULT_PATH}")
        elif os.getenv("TEMPL_EMBEDDING_PATH") and os.path.exists(os.getenv("TEMPL_EMBEDDING_PATH")):
            st.session_state.embedding_path = os.getenv("TEMPL_EMBEDDING_PATH")
            logger.info(f"Using embedding path from environment: {os.getenv('TEMPL_EMBEDDING_PATH')}")
        else:
            st.session_state.embedding_path = DEFAULT_EMBEDDING_PATH
            logger.info(f"Using default embedding path: {DEFAULT_EMBEDDING_PATH}")
    
    # Main content area with tabs
    tab1, tab2, tab3, tab4 = st.tabs([
        "1. Protein Embedding",
        "2. Template Finding",
        "3. Pose Generation",
        "4. Results"
    ])
    
    # Sidebar with global options
    with st.sidebar:
        st.header("Settings")
        
        # --- Embedding Settings ---
        st.sidebar.subheader("Embedding Settings")
        
        st.session_state.embedding_path = st.sidebar.text_input(
            "Embedding Database Path",
            value=st.session_state.embedding_path,
            help="Path to pre-computed protein embeddings"
        )
        
        # Check if embedding file exists and provide options
        if not os.path.exists(st.session_state.embedding_path):
            st.sidebar.warning(f"Warning: Embedding database not found at {st.session_state.embedding_path}")
            # Suggest absolute path if it exists
            if os.path.exists(ABSOLUTE_DEFAULT_PATH):
                st.sidebar.info(f"The embeddings file exists at: {ABSOLUTE_DEFAULT_PATH}")
                if st.sidebar.button("Use Absolute Path"):
                    st.session_state.embedding_path = ABSOLUTE_DEFAULT_PATH
                    st.experimental_rerun()
        else:
            st.sidebar.success(f"✅ Embedding file found at {st.session_state.embedding_path}")
        
        # Add diagnostics button
        if st.sidebar.button("Check Embedding Database"):
            with st.sidebar.expander("Database Diagnostics", expanded=True):
                with st.spinner("Analyzing embedding database..."):
                    try:
                        diagnostics = analyze_embedding_database(st.session_state.embedding_path)
                        if diagnostics["status"] == "success":
                            st.success(f"✅ Database loaded successfully with {diagnostics['pdb_count']} PDB IDs")
                            st.write(f"File: {diagnostics['file_path']}")
                            st.write(f"Size: {diagnostics['file_size_mb']} MB")
                            st.write(f"Modified: {diagnostics['last_modified']}")
                            
                            # Sample PDB IDs table with case information
                            if 'pdb_sample' in diagnostics and diagnostics['pdb_sample']:
                                st.write("Sample PDB IDs:")
                                st.write(", ".join(diagnostics['pdb_sample'][:5]))
                                
                                # Add note about case normalization if available
                                if 'case_normalization_note' in diagnostics:
                                    st.info(diagnostics['case_normalization_note'])
                                else:
                                    st.info("Note: PDB IDs are case-insensitive in searches (e.g., '1a1e' is the same as '1A1E')")
                            
                            # Consistency check
                            if diagnostics["embeddings_match_count"]:
                                st.success("✅ PDB ID count matches embedding count")
                            else:
                                st.error("❌ PDB ID count does NOT match embedding count")
                        else:
                            st.error(f"❌ Database analysis failed: {diagnostics['message']}")
                    except Exception as e:
                        st.error(f"Error analyzing database: {str(e)}")
                        
        # Other sidebar options
        embeddings_source = st.sidebar.radio(
            "Embedding Source",
            ["Pre-computed", "Generate on-demand"],
            index=0,
            help="Choose embedding source"
        )
        
        # Initialize EmbeddingManager once with the configured path
        try:
            embedding_manager = EmbeddingManager(embedding_path=st.session_state.embedding_path)
            logger.info(f"Initialized EmbeddingManager with path: {st.session_state.embedding_path}")
            # Check if embeddings can be loaded (but don't keep in memory)
            _ = embedding_manager.load_embeddings()
            embedding_manager.embeddings = {}  # Clear to save memory
            st.session_state.embedding_manager_initialized = True
        except Exception as e:
            logger.error(f"Failed to initialize EmbeddingManager: {e}")
            st.sidebar.error(f"Error initializing embedding manager: {e}")
            st.session_state.embedding_manager_initialized = False
        
        # Worker settings
        n_workers = st.slider(
            "Number of Workers",
            min_value=1,
            max_value=os.cpu_count() or 8,
            value=min(4, os.cpu_count() or 4),
            help="Number of parallel workers for computation"
        )
        
        # Advanced options
        with st.sidebar.expander("Advanced Options", expanded=False):
            # Add debug mode checkbox
            debug_mode = st.checkbox(
                "Debug Mode", 
                value=False,
                help="Enable additional diagnostic information for troubleshooting"
            )
            
            # Store debug mode in session state
            st.session_state.debug_mode = debug_mode
            
            # Cache settings 
            use_embedding_cache = st.checkbox(
                "Use Embedding Cache",
                value=True,
                help="Cache embeddings to disk for faster subsequent runs"
            )
            
            # SDF path override
            custom_sdf_path = st.text_input(
                "Custom SDF Path",
                value="",
                placeholder="Path to custom processed_ligands.sdf.gz file",
                help="Provide a custom path to the processed_ligands SDF file (leave blank for default)"
            )
            
            if custom_sdf_path:
                st.session_state.custom_sdf_path = custom_sdf_path

            # Add more advanced options as needed
        
        # Display debug file diagnostic tool if debug mode is enabled
        if debug_mode:
            with st.sidebar.expander("Debug: SDF File Diagnostics", expanded=True):
                st.write("Check for molecule by PDB ID in SDF file")
                debug_pdb_id = st.text_input(
                    "PDB ID to check", 
                    placeholder="e.g., 1a52",
                    help="Enter a 4-character PDB ID to check if it exists in the SDF file"
                )
                
                if st.button("Check SDF File"):
                    with st.spinner("Scanning SDF file..."):
                        try:
                            # Determine SDF path
                            sdf_path = custom_sdf_path if custom_sdf_path else "templ_pipeline/data/ligands/processed_ligands_new.sdf.gz"
                            possible_paths = [
                                sdf_path,  # Try as provided
                                os.path.join(os.getcwd(), sdf_path),  # Try relative to current directory
                                "/home/ubuntu/mcs/templ_pipeline/data/ligands/processed_ligands_new.sdf.gz",  # Try absolute path
                                "/home/ubuntu/mcs/mcs_bench/data/processed_ligands_new.sdf.gz"  # Try path from true_mcs_pipeline.py
                            ]
                            
                            # Find the first valid path
                            file_path = None
                            for path in possible_paths:
                                if os.path.exists(path):
                                    file_path = path
                                    break
                            
                            if not file_path:
                                st.error("SDF file not found in any of the expected locations")
                                return
                                
                            # Scan file for the PDB ID
                            st.info(f"Scanning file: {file_path}")
                            pdb_matches = []
                            total_mols = 0
                            
                            with gzip.open(file_path, 'rb') as fh:
                                for mol in Chem.ForwardSDMolSupplier(fh, removeHs=False, sanitize=False):
                                    total_mols += 1
                                    if not mol:
                                        continue
                                        
                                    # Check if name contains the PDB ID
                                    if mol.HasProp("_Name"):
                                        mol_name = mol.GetProp("_Name")
                                        
                                        # Try different matching patterns
                                        if debug_pdb_id and (
                                            debug_pdb_id.lower() == mol_name.lower()[:4] or 
                                            debug_pdb_id.lower() in mol_name.lower() or
                                            mol_name.lower().startswith(debug_pdb_id.lower())
                                        ):
                                            # Found a potential match
                                            mol_info = {
                                                "name": mol_name,
                                                "atoms": mol.GetNumAtoms(),
                                                "bonds": mol.GetNumBonds(),
                                                "conformers": mol.GetNumConformers(),
                                                "smiles": Chem.MolToSmiles(mol) if mol.GetNumAtoms() > 0 else "N/A"
                                            }
                                            pdb_matches.append(mol_info)
                            
                            # Show results
                            st.write(f"Total molecules in SDF: {total_mols}")
                            
                            if debug_pdb_id:
                                if pdb_matches:
                                    st.success(f"Found {len(pdb_matches)} matches for '{debug_pdb_id}'")
                                    for i, match in enumerate(pdb_matches):
                                        st.write(f"Match {i+1}:")
                                        for key, value in match.items():
                                            st.write(f"- {key}: {value}")
                                else:
                                    st.error(f"No matches found for '{debug_pdb_id}' in the SDF file")
                                    
                                    # Suggest potential similar PDB IDs
                                    st.write("Showing a sample of molecule names from the file to help debug:")
                                    sample_names = []
                                    with gzip.open(file_path, 'rb') as fh:
                                        for mol in Chem.ForwardSDMolSupplier(fh, removeHs=False, sanitize=False):
                                            if mol and mol.HasProp("_Name"):
                                                sample_names.append(mol.GetProp("_Name"))
                                                if len(sample_names) >= 10:
                                                    break
                                    
                                    st.write(", ".join(sample_names))
                        except Exception as e:
                            st.error(f"Error scanning SDF file: {str(e)}")
                            import traceback
                            st.code(traceback.format_exc(), language="python")
    
    # Tab 1: Protein Embedding
    with tab1:
        st.header("Protein Embedding Generation")
        st.write("Upload a protein PDB file to generate or retrieve its embedding")
        
        protein_file = st.file_uploader(
            "Upload Protein PDB",
            type=["pdb"],
            help="PDB file containing protein structure"
        )
        
        protein_id = st.text_input(
            "Or enter PDB ID",
            value="",
            placeholder="e.g., 1a1e",
            help="PDB ID to retrieve from embedding database"
        )
        
        target_chain = st.text_input(
            "Target Chain (optional)",
            value="",
            placeholder="e.g., A",
            help="Specific protein chain to use"
        )
        
        # Add a checkbox to show available PDB IDs
        if st.checkbox("Show sample of available PDB IDs"):
            with st.spinner("Loading sample PDB IDs..."):
                sample_ids = get_sample_pdb_ids(st.session_state.embedding_path, limit=30)
                if sample_ids:
                    st.write("Examples of PDB IDs available in the pre-computed database:")
                    # Display in a more compact format, perhaps in columns
                    cols = st.columns(3)
                    for i, pid in enumerate(sample_ids):
                        cols[i % 3].write(pid)
                    
                    # Add a note about case-insensitivity
                    st.info("Note: PDB IDs are case-insensitive (e.g., '1a1e' is the same as '1A1E')")
                else:
                    st.warning("Could not retrieve sample PDB IDs.")
        
        generate_button = st.button("Generate/Retrieve Embedding", use_container_width=True)
        
        if generate_button:
            with st.spinner("Processing protein..."):
                try:
                    if protein_file:
                        # Save uploaded file to temp location
                        pdb_path = read_pdb_file(protein_file)
                        pdb_id = Path(pdb_path).stem
                        
                        # Get embedding
                        embedding_result = get_embedding(
                            pdb_path,
                            embedding_path=st.session_state.embedding_path,
                            chain_id=target_chain if target_chain else None
                        )
                        # Check if the result is a tuple (newer API) or just an array (older API)
                        if isinstance(embedding_result, tuple):
                            protein_embedding, chains_used = embedding_result
                            if protein_embedding is None:
                                raise ValueError(f"No embedding found for PDB file {pdb_path}")
                        else:
                            protein_embedding = embedding_result
                            chains_used = ""
                            
                    elif protein_id:
                        # Get embedding by ID - now using a more robust error handling approach
                        try:
                            # First, check if the PDB ID exists in the database
                            # This now uses the consistent internal implementation
                            if not is_pdb_id_in_database(protein_id, st.session_state.embedding_path):
                                st.error(f"⚠️ PDB ID '{protein_id}' is not found in the pre-computed embedding database.")
                                st.info("Please either: \n"
                                        "1. Upload a PDB file for this protein to generate an embedding on-demand, or\n"
                                        "2. Use a different PDB ID that exists in the database.")
                                
                                # Show available PDB IDs as examples to help the user
                                with st.expander("Available PDB IDs in database", expanded=True):
                                    sample_pdb_ids = get_sample_pdb_ids(st.session_state.embedding_path, limit=20)
                                    if sample_pdb_ids:
                                        st.write("Examples of PDB IDs available in the database:")
                                        # Display in columns for better readability
                                        cols = st.columns(4)
                                        for i, pid in enumerate(sample_pdb_ids):
                                            cols[i % 4].write(pid)
                                        
                                        # Add note about case sensitivity
                                        st.info("Note: PDB IDs are case-insensitive (e.g., '1a1e' is the same as '1A1E')")
                                    else:
                                        st.warning("Could not retrieve sample PDB IDs. The embedding database might be inaccessible.")
                                        
                                # Check embedding file existence
                                with st.expander("Check embedding database file"):
                                    db_path = st.session_state.embedding_path
                                    if os.path.exists(db_path):
                                        st.success(f"✅ Embedding file exists at: {db_path}")
                                        file_size = os.path.getsize(db_path) / (1024*1024)
                                        st.write(f"File size: {file_size:.2f} MB")
                                    else:
                                        st.error(f"❌ Embedding file NOT found at: {db_path}")
                                        
                                return
                            
                            # If we get here, the PDB ID is valid, so try to get the embedding
                            embedding_result = get_embedding(
                                protein_id,
                                embedding_path=st.session_state.embedding_path,
                                chain_id=target_chain if target_chain else None
                            )
                            
                            # Process the result
                            if isinstance(embedding_result, tuple):
                                protein_embedding, chains_used = embedding_result
                                if protein_embedding is None:
                                    st.error(f"⚠️ Retrieved embedding for {protein_id} is None.")
                                    return
                            else:
                                protein_embedding = embedding_result
                                chains_used = ""
                                
                        except ValueError as e:
                            st.error(f"⚠️ {str(e)}")
                            st.info("Please check that the PDB ID is correct or upload a PDB file.")
                            return
                        except Exception as e:
                            st.error(f"Unexpected error retrieving embedding: {str(e)}")
                            logger.error(f"Error retrieving embedding for {protein_id}: {str(e)}", exc_info=True)
                            return
                    else:
                        st.error("Please provide either a PDB file or a PDB ID")
                        return
                    
                    # Store in session state
                    ss.protein_embedding = protein_embedding
                    # Also store chain information if available
                    if 'chains_used' in locals() and chains_used:
                        ss.chains_used = chains_used
                    
                    # Store the protein ID in session state for use in template finding
                    if protein_file:
                        ss.protein_pdb_id = pdb_id
                    elif protein_id:
                        ss.protein_pdb_id = protein_id
                        
                    st.success(f"Successfully generated embedding of shape {protein_embedding.shape}")
                    if 'chains_used' in locals() and chains_used:
                        st.info(f"Used chain(s): {chains_used}")
                    if 'protein_pdb_id' in ss:
                        st.info(f"Protein PDB ID: {ss.protein_pdb_id}")
                    
                    # Show embedding visualization
                    st.subheader("Embedding Visualization")
                    st.line_chart(protein_embedding)  # Show full embedding dimensions
                    
                except Exception as e:
                    st.error(f"Error generating embedding: {str(e)}")
                    logger.error(f"Error generating embedding: {str(e)}", exc_info=True)
                    
                    # Offer solutions if it's a common error
                    if "No embedding found" in str(e) or "No PDB file provided" in str(e):
                        st.info("Please upload a PDB file to generate an embedding on-demand or choose a different PDB ID.")
                        
                        if not st.session_state.get("shown_sample_ids", False):
                            with st.expander("Show examples of available PDB IDs"):
                                sample_pdb_ids = get_sample_pdb_ids(st.session_state.embedding_path, limit=20)
                                if sample_pdb_ids:
                                    st.write("Examples of PDB IDs available in the database:")
                                    st.write(", ".join(sample_pdb_ids))
                                    st.session_state.shown_sample_ids = True
    
    # Tab 2: Template Finding
    with tab2:
        st.header("Template Finding")
        st.write("Find similar templates using protein embedding")
        
        if ss.protein_embedding is None:
            st.info("Please generate a protein embedding in the first tab before finding templates")
        elif "protein_pdb_id" not in ss or not ss.protein_pdb_id:
            st.warning("Protein PDB ID not found. Please generate an embedding in the first tab using a valid PDB ID.")
        else:
            # Template selection parameters
            k = st.slider(
                "Number of Templates (K)",
                min_value=1,
                max_value=200,
                value=100,
                help="Number of most similar templates to return"
            )
            
            similarity_threshold = st.slider(
                "Similarity Threshold",
                min_value=0.0,
                max_value=1.0,
                value=0.7,
                step=0.01,
                help="Minimum similarity score for templates"
            )
            
            use_threshold = st.checkbox(
                "Use Similarity Threshold",
                value=False,
                help="If checked, use threshold instead of K-nearest neighbors"
            )
            
            # Advanced options
            with st.expander("Advanced Template Options"):
                enable_uniprot = st.checkbox(
                    "Enable UniProt Exclusion",
                    value=False,
                    help="Exclude templates with same UniProt ID"
                )
                enable_pdb = st.checkbox(
                    "Enable PDB Filtering",
                    value=False,
                    help="Filter templates by PDB ID list"
                )
            
            find_button = st.button("Find Templates", use_container_width=True)
            
            if find_button:
                with st.spinner("Finding templates..."):
                    try:
                        # Set threshold parameter based on checkbox
                        threshold_param = similarity_threshold if use_threshold else None
                        
                        # Check if we have a valid PDB ID before proceeding
                        if not ss.protein_pdb_id:
                            st.error("Missing protein PDB ID. Please generate an embedding in the first tab using a valid PDB ID.")
                            return
                            
                        # Find templates
                        templates = select_templates(
                            target_pdb_id=ss.protein_pdb_id,
                            target_embedding=ss.protein_embedding,
                            embedding_path=st.session_state.embedding_path,
                            k=k,
                            similarity_threshold=threshold_param,
                            enable_uniprot_exclusion=enable_uniprot,
                            enable_pdb_filtering=enable_pdb,
                            return_similarities=True
                        )
                        
                        # Store results
                        ss.template_results = templates
                        
                        # Display results
                        st.success(f"Found {len(templates)} templates")
                        
                        # Create table of results
                        if templates:
                            template_df = {
                                "PDB ID": [t[0] for t in templates],
                                "Similarity": [f"{t[1]:.4f}" for t in templates]
                            }
                            st.dataframe(template_df, use_container_width=True)
                        
                    except Exception as e:
                        st.error(f"Error finding templates: {str(e)}")
            
            # Add section for query ligand upload after template finding
            st.subheader("Query Ligand Selection")
            st.write("Upload a query ligand molecule for docking")
            
            # Option to upload ligand file
            ligand_file = st.file_uploader(
                "Upload Query Ligand",
                type=["sdf", "mol"],
                help="SDF or MOL file of the ligand to dock"
            )
            
            # Sample SMILES input as alternative
            st.write("Or enter ligand structure as SMILES")
            smiles_input = st.text_input(
                "SMILES",
                value="",
                placeholder="e.g., CCO",
                help="SMILES representation of query ligand"
            )
            
            # Create query molecule button
            create_query_button = st.button("Set as Query Molecule", use_container_width=True)
            
            if create_query_button:
                try:
                    query_mol = None
                    
                    if ligand_file:
                        # Read the SDF/MOL file
                        ligand_bytes = ligand_file.read()
                        supplier = Chem.SDMolSupplier()
                        supplier.SetData(ligand_bytes)
                        
                        # Get the first molecule
                        for mol in supplier:
                            if mol:
                                query_mol = mol
                                break
                                
                        if query_mol:
                            st.success("Successfully loaded ligand from file!")
                    
                    elif smiles_input:
                        # Create molecule from SMILES
                        query_mol = Chem.MolFromSmiles(smiles_input)
                        
                        if query_mol:
                            # First, generate 2D coordinates
                            AllChem.Compute2DCoords(query_mol)
                            # Then, add hydrogens and generate 3D coordinates
                            query_mol = Chem.AddHs(query_mol)
                            AllChem.EmbedMolecule(query_mol)
                            AllChem.MMFFOptimizeMolecule(query_mol)
                            st.success("Successfully created ligand from SMILES!")
                    
                    else:
                        st.error("Please either upload a ligand file or enter a SMILES string")
                        return
                    
                    if query_mol:
                        # Remove hydrogens and store the query molecule in session state
                        query_mol = Chem.RemoveHs(query_mol)
                        ss.query_mol = query_mol
                        
                        # Display the molecule
                        st.subheader("Query Ligand Visualization")
                        col1, col2 = st.columns(2)
                        with col1:
                            # Use the same style for 2D visualization
                            display_molecule(query_mol)
                        with col2:
                            viewer = initialize_3d_viewer(width=350, height=300)
                            # Use the same style for 3D visualization
                            display_3d_molecule(query_mol, viewer, style="stick")
                        
                        # Show info about the molecule
                        st.write(f"Atoms: {query_mol.GetNumAtoms()}")
                        st.write(f"Bonds: {query_mol.GetNumBonds()}")
                        
                        # Provide guidance to proceed
                        st.info("You can now proceed to the Pose Generation tab to generate conformers using this query ligand and the selected templates.")
                
                except Exception as e:
                    st.error(f"Error processing ligand: {str(e)}")
    
    # Tab 3: Pose Generation
    with tab3:
        # Default values for parameters
        n_conformers = 200
        n_workers = min(4, os.cpu_count() or 4)
        
        # Get template molecules from results
        template_mols = []
        if ss.template_results:
            # Extract template PDB IDs
            template_pdbs = [result[0] for result in ss.template_results[:5]]
            
            try:
                st.write("Loading template molecules from PDBbind...")
                
                # First try to load from the pre-processed ligands file
                template_mols = load_templates_from_processed_sdf(template_pdbs)
                
                if template_mols:
                    valid_templates = [mol for mol in template_mols 
                                      if not (mol.HasProp("_IsPlaceholder") and mol.GetProp("_IsPlaceholder") == "True")]
                    
                    # Check if we have any valid non-placeholder templates
                    if valid_templates:
                        st.success(f"Loaded {len(valid_templates)} valid template molecules from pre-processed data")
                        
                        # Show warning if some templates are placeholders
                        if len(valid_templates) < len(template_mols):
                            st.warning(f"{len(template_mols) - len(valid_templates)} templates are placeholders and may not work well for conformer generation")
                    else:
                        st.warning("All loaded templates are placeholders without real 3D coordinates")
                        
                        # Try to explain why we couldn't find real templates
                        st.info("""
                        This typically happens when:
                        1. The PDB IDs exist in the embedding database but not in the ligand SDF file
                        2. The PDB IDs in the SDF file have a different format than expected
                        3. The SDF file path is incorrect or the file is corrupt
                        """)
                else:
                    # Fall back to individual PDBbind files if needed
                    from templ_pipeline.core.utils import find_pdbbind_paths
                    
                    for pdb_id in template_pdbs:
                        try:
                            # Find paths to PDBbind files
                            paths = find_pdbbind_paths(pdb_id)
                            
                            if paths["ligand"] and os.path.exists(paths["ligand"]):
                                # Load the template ligand
                                supplier = Chem.SDMolSupplier(paths["ligand"])
                                template_mol = None
                                
                                for mol in supplier:
                                    if mol:
                                        template_mol = mol
                                        # Set the PDB ID as name property
                                        template_mol.SetProp("_Name", pdb_id)
                                        
                                        # Also store which protein this came from
                                        if paths["protein"]:
                                            template_mol.SetProp("protein_file", paths["protein"])
                                        
                                        template_mols.append(template_mol)
                                        st.success(f"Loaded template molecule from {pdb_id}")
                                        break
                                
                                if template_mol is None:
                                    st.warning(f"Could not read molecule from {paths['ligand']}")
                            else:
                                st.warning(f"Could not find ligand file for PDB ID: {pdb_id}")
                                
                        except Exception as e:
                            st.error(f"Error loading template {pdb_id}: {str(e)}")
                
                # If we couldn't load any real molecules, use a placeholder as fallback
                if not template_mols and template_pdbs:
                    st.warning("Could not load actual template molecules. Using placeholder molecules instead.")
                    for pdb_id in template_pdbs:
                        mol = Chem.MolFromSmiles("C")  # Placeholder
                        mol.SetProp("_Name", pdb_id.lower())  # Ensure lowercase
                        mol.SetProp("_IsPlaceholder", "True")
                        template_mols.append(mol)
                        
                # Display the loaded templates
                if template_mols:
                    st.subheader("Selected Templates")
                    
                    # Create tabs for template visualization
                    template_tabs = st.tabs([f"Template {i+1}: {mol.GetProp('_Name')}" for i, mol in enumerate(template_mols)])
                    
                    for i, (mol, tab) in enumerate(zip(template_mols, template_tabs)):
                        with tab:
                            col1, col2 = st.columns([1, 1])
                            
                            with col1:
                                # Show 2D structure
                                display_molecule(mol, width=300, height=300)
                                
                                # Show template properties and validation
                                st.write(f"PDB ID: {mol.GetProp('_Name')}")
                                st.write(f"Atoms: {mol.GetNumAtoms()}")
                                st.write(f"Bonds: {mol.GetNumBonds()}")
                                
                                # Calculate more detailed molecular properties
                                try:
                                    prop_items = []
                                    
                                    # Is this a placeholder?
                                    is_placeholder = mol.HasProp("_IsPlaceholder") and mol.GetProp("_IsPlaceholder") == "True"
                                    if is_placeholder:
                                        st.error("⚠️ This is a placeholder molecule without real 3D coordinates")
                                    
                                    # Check if the template is valid
                                    mol_copy = Chem.Mol(mol)
                                    try:
                                        Chem.SanitizeMol(mol_copy)
                                        if not is_placeholder:
                                            st.success("✅ Molecule passed chemical validation")
                                    except Exception as e:
                                        st.error(f"❌ Chemical validation failed: {str(e)}")
                                    
                                    # Check for 3D conformers
                                    if mol.GetNumConformers() > 0:
                                        st.success(f"✅ Has {mol.GetNumConformers()} 3D conformer(s)")
                                    else:
                                        st.error("❌ No 3D conformers")
                                    
                                    # Check for rings, which are important for MCS
                                    ring_count = Chem.rdMolDescriptors.CalcNumRings(mol)
                                    if ring_count > 0:
                                        prop_items.append(f"Rings: {ring_count}")
                                    else:
                                        prop_items.append("Rings: 0 (may affect MCS search)")
                                    
                                    # Show heavy atom count
                                    heavy_atoms = mol.GetNumHeavyAtoms()
                                    prop_items.append(f"Heavy atoms: {heavy_atoms}")
                                    
                                    # Calculate fragment count
                                    frag_count = len(Chem.GetMolFrags(mol))
                                    prop_items.append(f"Fragments: {frag_count}")
                                    
                                    # Show SMILES for reference
                                    try:
                                        smiles = Chem.MolToSmiles(mol)
                                        prop_items.append(f"SMILES: {smiles}")
                                    except:
                                        prop_items.append("SMILES: Error generating")
                                    
                                    # Display properties
                                    for item in prop_items:
                                        st.write(item)
                                except Exception as e:
                                    st.error(f"Error analyzing template: {str(e)}")
                            
                            with col2:
                                # Show 3D structure if available
                                if mol.GetNumConformers() > 0:
                                    viewer = initialize_3d_viewer(width=300, height=300)
                                    display_3d_molecule(mol, viewer, style="stick")
                                else:
                                    st.warning("No 3D conformer available for visualization")
                                    
                                # Show similarity score if available in session state
                                if 'template_results' in ss and len(ss.template_results) > i:
                                    similarity = ss.template_results[i][1]
                                    st.info(f"Embedding similarity score: {similarity:.4f}")
                
            except Exception as e:
                st.error(f"Error loading templates: {str(e)}")
                import traceback
                st.error(traceback.format_exc())
                
                # Fallback to placeholder molecules
                st.warning("Using placeholder molecules as fallback due to errors")
                template_mols = []
                for pdb_id in template_pdbs:
                    mol = Chem.MolFromSmiles("C")  # Placeholder
                    mol.SetProp("_Name", pdb_id.lower())  # Ensure lowercase
                    mol.SetProp("_IsPlaceholder", "True")
                    template_mols.append(mol)
        else:
            st.info("No templates selected yet. Please use the Template Finding tab to find suitable templates.")
        
        process_pose_generation(tab3, template_mols, ss.query_mol, n_conformers, n_workers)
    
    # Tab 4: Results Visualization
    with tab4:
        render_results_tab(tab4)

if __name__ == "__main__":
    main()
