<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Templates Workflow - Updated from Code</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #000000;
            background: #ffffff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
            border-radius: 16px;
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 50px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 3em;
            font-weight: 300;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .content {
            padding: 50px;
        }
        
        .diagram-section {
            margin-bottom: 60px;
        }
        
        .section-title {
            font-size: 2.2em;
            color: #2c3e50;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 4px solid #3498db;
            font-weight: 400;
        }
        
        .mermaid {
            text-align: center;
            margin: 40px 0;
            padding: 40px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 16px;
            border: 2px solid #dee2e6;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .reference-section {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 50px;
            border-radius: 16px;
            margin-top: 50px;
        }
        
        .reference-section h2 {
            color: white;
            margin-bottom: 40px;
            font-size: 2.2em;
            font-weight: 300;
        }
        
        .function-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }
        
        .function-card {
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .function-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }
        
        .function-card h3 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid rgba(52, 152, 219, 0.3);
            padding-bottom: 10px;
        }
        
        .function-card ul {
            margin: 20px 0;
            padding-left: 25px;
        }
        
        .function-card li {
            margin: 12px 0;
            line-height: 1.6;
        }
        
        .function-card strong {
            color: #3498db;
        }
        
        .workflow-features {
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 12px;
            margin-top: 40px;
        }
        
        .workflow-features h3 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 1.4em;
        }
        
        .workflow-features ul {
            margin: 20px 0;
            padding-left: 25px;
        }
        
        .workflow-features li {
            margin: 12px 0;
            line-height: 1.6;
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 40px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 18px;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            font-size: 0.95em;
            font-weight: 500;
        }
        
        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Templates Workflow - Updated from Code</h1>
            <p>Protein superimposition workflow based on actual implementation in templates.py</p>
        </div>
        
        <div class="content">
            <div id="diagram" class="diagram-section">
                <h2 class="section-title">Templates Workflow Diagram</h2>
                <p style="margin-bottom: 30px; color: #555; font-size: 1.1em;">
                    The diagram below shows the complete protein superimposition workflow for template-based pose prediction, 
                    based on the actual implementation in templates.py.
                </p>
                
                <div class="mermaid">
flowchart TD
    Start["transform_ligand<br/>Primary Orchestrator"] --> LoadRef["Load Reference Protein<br/>load_reference_protein()"]
    Start --> LoadTarget["Load Target Data<br/>load_target_data()"]
    
    LoadRef --> CheckBiotite{"Biotite Available?"}
    CheckBiotite -->|No| FailBiotite["Return None<br/>Biotite not available"]
    CheckBiotite -->|Yes| LoadMob["Load Mobile Protein<br/>bsio.load_structure(mob_pdb)"]
    
    LoadTarget --> CheckSMILES{"Target SMILES Valid?"}
    CheckSMILES -->|No| FailSMILES["Return None<br/>Invalid SMILES"]
    CheckSMILES -->|Yes| CreateTarget["Create Target Molecule<br/>Chem.MolFromSmiles() + AddHs()"]
    
    LoadMob --> FilterAAs["Filter Amino Acids<br/>filter_amino_acids()"]
    CreateTarget --> FilterAAs
    
    FilterAAs --> CheckAAs{"Enough Amino Acids?<br/>len(ref_prot) > 0 AND len(mob_prot) > 0"}
    CheckAAs -->|No| FailAAs["Return None<br/>No amino acids found"]
    CheckAAs -->|Yes| ValidateChains["Validate & Select Chains<br/>_validate_and_select_chains()"]
    
    ValidateChains --> CheckChains{"Valid Chains Found?"}
    CheckChains -->|No| FailChains["Return None<br/>No valid chains"]
    CheckChains -->|Yes| ExtractCA["Extract C-Alpha Atoms<br/>atom_name == 'CA'"]
    
    ExtractCA --> CheckCA{"Enough CA Atoms?<br/>MIN_CA_ATOMS_FOR_ALIGNMENT = 3"}
    CheckCA -->|No| FailCA["Return None<br/>Insufficient CA atoms"]
    CheckCA -->|Yes| Level1["Level 1: Homologous Alignment<br/>For similar-length sequences"]
    
    Level1 --> CheckLength{"Sequence Length Similar?<br/>Length difference < 30%"}
    CheckLength -->|No| Level2["Level 2: Sequence Alignment<br/>_align_with_biotite_sequence()"]
    CheckLength -->|Yes| TryHomologs["Try superimpose_homologs<br/>BLOSUM62 matrix, gap_penalty=-10"]
    
    TryHomologs --> CheckAnchors{"Sufficient Anchors?<br/>len(fixed_idx) >= 3"}
    CheckAnchors -->|No| Level2
    CheckAnchors -->|Yes| CalcRMSD1["Calculate CA RMSD<br/>struc.rmsd()"]
    
    Level2 --> CheckSeq{"Sequence Alignment Success?<br/>BLOSUM62 + optimal alignment"}
    CheckSeq -->|No| Level3["Level 3: 3Di Structural<br/>_align_with_3di_structural()"]
    CheckSeq -->|Yes| CalcRMSD2["Calculate CA RMSD<br/>struc.rmsd()"]
    
    Level3 --> Check3Di{"3Di Available & Success?<br/>STRUCTURAL_ALPHABET_AVAILABLE"}
    Check3Di -->|No| Level4["Level 4: Centroid Fallback<br/>_align_with_centroid_fallback()"]
    Check3Di -->|Yes| CalcRMSD3["Calculate CA RMSD<br/>struc.rmsd()"]
    
    Level4 --> CheckMin{"Min Atoms Available?<br/>MIN_CA_ATOMS_FOR_ALIGNMENT"}
    CheckMin -->|No| FailMin["Return None<br/>Insufficient atoms"]
    CheckMin -->|Yes| SimpleAlign["Simple Superimposition<br/>superimpose()<br/>First N atoms only"]
    SimpleAlign --> CalcRMSD4["Calculate CA RMSD<br/>struc.rmsd()"]
    
    CalcRMSD1 --> CheckThreshold{"CA RMSD <= Threshold?<br/>CA_RMSD_THRESHOLD = 10.0Å"}
    CalcRMSD2 --> CheckThreshold
    CalcRMSD3 --> CheckThreshold
    CalcRMSD4 --> CheckThreshold
    
    CheckThreshold -->|No| Fallback["Apply Fallback Thresholds<br/>CA_RMSD_FALLBACK_THRESHOLDS<br/>[10.0, 15.0, 20.0]Å"]
    CheckThreshold -->|Yes| Transform["Transform Ligand Coordinates<br/>Apply transformation matrix"]
    
    Fallback --> CheckTemplates{"Any Templates Pass?<br/>filter_templates_by_ca_rmsd()"}
    CheckTemplates -->|No| BestTemplate["Use Best Available Template<br/>get_templates_with_progressive_fallback()"]
    CheckTemplates -->|Yes| Transform
    
    Transform --> CheckConformers{"Conformers Available?<br/>lig.GetNumConformers() > 0"}
    CheckConformers -->|No| FailConformers["Return None<br/>No conformers in ligand"]
    CheckConformers -->|Yes| ApplyMatrix["Apply Transformation Matrix<br/>transformation.apply(coords)"]
    
    ApplyMatrix --> SetCoordinates["Set Transformed Coordinates<br/>Point3D for each atom"]
    SetCoordinates --> ValidateBonds["Validate Bond Lengths<br/>Check 0.5-3.0Å range"]
    ValidateBonds --> AddMetadata["Add Metadata Properties<br/>ca_rmsd, template_pid<br/>alignment_method, anchor_count"]
    AddMetadata --> Success["Return Transformed Ligand<br/>Enhanced with metadata"]
    
    BestTemplate --> Success
    
    classDef startEnd fill:#2ecc71,stroke:#27ae60,stroke-width:3px,color:#000
    classDef process fill:#3498db,stroke:#2980b9,stroke-width:2px,color:#000
    classDef decision fill:#f39c12,stroke:#e67e22,stroke-width:2px,color:#000
    classDef error fill:#e74c3c,stroke:#c0392b,stroke-width:2px,color:#000
    classDef success fill:#27ae60,stroke:#229954,stroke-width:3px,color:#000
    classDef alignment fill:#9b59b6,stroke:#8e44ad,stroke-width:2px,color:#000
    classDef transformation fill:#e67e22,stroke:#d35400,stroke-width:2px,color:#000
    classDef validation fill:#34495e,stroke:#2c3e50,stroke-width:2px,color:#000
    classDef fallback fill:#e74c3c,stroke:#c0392b,stroke-width:2px,color:#000
    
    class Start,Success startEnd
    class LoadRef,LoadTarget,LoadMob,CreateTarget,FilterAAs,ValidateChains,ExtractCA,ApplyMatrix,SetCoordinates,AddMetadata process
    class CheckBiotite,CheckSMILES,CheckAAs,CheckChains,CheckCA,CheckLength,CheckAnchors,CheckSeq,Check3Di,CheckMin,CheckThreshold,CheckTemplates,CheckConformers decision
    class FailBiotite,FailSMILES,FailAAs,FailChains,FailCA,FailMin,FailConformers error
    class Level1,Level2,Level3,Level4,TryHomologs,CalcRMSD1,CalcRMSD2,CalcRMSD3,CalcRMSD4,SimpleAlign alignment
    class Transform,ApplyMatrix,SetCoordinates transformation
    class ValidateBonds validation
    class Fallback,BestTemplate fallback
                </div>
            </div>
            
            <div id="reference" class="reference-section">
                <h2>Function Reference Table</h2>
                <p style="margin-bottom: 30px; opacity: 0.9; font-size: 1.1em;">
                    Comprehensive reference of all functions used in the templates workflow, 
                    with detailed descriptions of what each function actually does.
                </p>
                
                <div class="function-grid">
                    <div class="function-card">
                        <h3>Data Loading Functions</h3>
                        <ul>
                            <li><strong>load_reference_protein()</strong>: Loads reference protein structure from PDB file using biotite. Validates file existence and uses bsio.load_structure() to parse the PDB format. Returns AtomArray object or None if loading fails, with comprehensive error logging for debugging file access issues.</li>
                            <li><strong>load_target_data()</strong>: Creates target molecule from SMILES string and adds hydrogens with coordinates. Validates SMILES syntax using Chem.MolFromSmiles(), then adds hydrogens using Chem.AddHs() for accurate molecular representation. Returns tuple of (smiles, molecule) or (None, None) if creation fails.</li>
                            <li><strong>filter_amino_acids()</strong>: Extracts only protein residues from biotite AtomArray structures. Uses biotite's built-in amino acid filtering to separate protein chains from ligands, water molecules, and other non-protein components. Essential for structural alignment of protein backbones.</li>
                            <li><strong>get_chains()</strong>: Identifies available protein chains in biotite AtomArray structures. Returns list of unique chain identifiers present in the structure, enabling chain-specific processing and validation of binding site chains from embedding data.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Chain Validation Functions</h3>
                        <ul>
                            <li><strong>_validate_and_select_chains()</strong>: Validates binding site chains from embedding data with fallback to all available chains. Checks if specified chains exist in both reference and mobile structures, falling back to all chains if validation fails. Ensures sufficient CA atoms for alignment (minimum 3) and provides detailed logging of chain selection decisions.</li>
                            <li><strong>MIN_CA_ATOMS_FOR_ALIGNMENT = 3</strong>: Minimum number of C-alpha atoms required for reliable structural alignment. Used throughout the alignment pipeline to ensure sufficient anchor points for superimposition, preventing alignment failures due to insufficient structural data.</li>
                            <li><strong>MIN_ANCHOR_RESIDUES = 15</strong>: Minimum number of anchor residues required for homologous alignment. Ensures quality alignment by requiring sufficient structurally similar residues for reliable superimposition of protein backbones.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Level 1: Homologous Alignment</h3>
                        <ul>
                            <li><strong>superimpose_homologs()</strong>: Performs homologous alignment for similar-length sequences using BLOSUM62 substitution matrix. Requires sequence length similarity (< 30% difference) and uses gap penalty of -10 with terminal penalty enabled. Extracts anchor residues and performs superimposition using fixed and mobile indices from alignment.</li>
                            <li><strong>BLOSUM_GAP_PENALTY = -10</strong>: Gap penalty used in sequence alignment algorithms. Balances the trade-off between alignment coverage and quality, ensuring robust alignment across diverse protein sequences while maintaining structural relevance.</li>
                            <li><strong>MIN_ANCHOR_RESIDUES = 15</strong>: Minimum anchor residues for homologous alignment quality control. Ensures sufficient structurally similar residues are identified for reliable protein superimposition and prevents poor alignments with insufficient anchor points.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Level 2: Sequence Alignment</h3>
                        <ul>
                            <li><strong>_align_with_biotite_sequence()</strong>: Performs optimal sequence alignment using biotite's sequence tools. Converts protein structures to sequences using to_sequence(), then performs optimal alignment with BLOSUM62 matrix and gap penalties. Extracts anchor residues and calculates RMSD for quality assessment.</li>
                            <li><strong>to_sequence()</strong>: Converts biotite AtomArray protein structures to amino acid sequences. Extracts one-letter amino acid codes from protein structures, enabling sequence-based alignment when structural similarity is insufficient for homologous alignment.</li>
                            <li><strong>align_optimal()</strong>: Performs optimal sequence alignment using dynamic programming. Uses BLOSUM62 substitution matrix with configurable gap penalties to find the best alignment between protein sequences, returning alignment objects with trace information.</li>
                            <li><strong>_rmsd_from_alignment()</strong>: Extracts corresponding residues from alignment and performs superimposition. Creates substitution matrix for anchor quality assessment, identifies structurally similar anchors without gaps, and performs superimposition to calculate RMSD and transformation matrix.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Level 3: 3Di Structural Alignment</h3>
                        <ul>
                            <li><strong>_align_with_3di_structural()</strong>: Uses 3Di structural alphabet for remote homolog alignment. Converts protein structures to 3Di sequences using strucalph.to_3di(), then performs alignment using 3Di substitution matrix. Specialized for proteins with poor sequence similarity but structural similarity.</li>
                            <li><strong>STRUCTURAL_ALPHABET_AVAILABLE</strong>: Boolean flag indicating 3Di structural alphabet availability. Checks if biotite.structure.alphabet module is available, enabling 3Di structural alignment for remote homologs when sequence-based methods fail.</li>
                            <li><strong>strucalph.to_3di()</strong>: Converts protein structures to 3Di structural alphabet sequences. Represents protein structures using 3Di structural alphabet, capturing structural motifs rather than sequence information for alignment of evolutionarily distant proteins.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Level 4: Centroid Fallback</h3>
                        <ul>
                            <li><strong>_align_with_centroid_fallback()</strong>: Simple centroid-based alignment as final fallback. Uses first N atoms from both structures (minimum 3) and performs basic superimposition using struc.superimpose(). Provides basic alignment when all other methods fail, though may be less accurate.</li>
                            <li><strong>superimpose()</strong>: Basic structural superimposition function from biotite. Performs rigid body transformation to align two structures, returning fitted structure and transformation matrix. Used in centroid fallback and other alignment methods.</li>
                            <li><strong>MIN_CA_ATOMS_FOR_ALIGNMENT = 3</strong>: Minimum atoms required for centroid alignment. Ensures sufficient structural data for basic superimposition, preventing alignment failures due to insufficient atoms.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Quality Assessment Functions</h3>
                        <ul>
                            <li><strong>rmsd()</strong>: Calculates root mean square deviation between aligned structures. Measures structural similarity by computing RMSD between corresponding atoms, providing quantitative assessment of alignment quality and structural similarity.</li>
                            <li><strong>filter_templates_by_ca_rmsd()</strong>: Filters templates by CA RMSD threshold. Parses "ca_rmsd" property from template molecules and filters out templates exceeding the threshold. Supports infinite threshold to include all templates.</li>
                            <li><strong>CA_RMSD_THRESHOLD = 10.0</strong>: Primary CA RMSD quality threshold in Angstroms. Templates with RMSD above this threshold are considered low quality and filtered out unless fallback thresholds are applied.</li>
                            <li><strong>CA_RMSD_FALLBACK_THRESHOLDS = [10.0, 15.0, 20.0]</strong>: Progressive fallback thresholds for CA RMSD filtering. Applied sequentially when primary threshold yields no templates, gradually relaxing quality requirements to ensure template availability.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Coordinate Transformation Functions</h3>
                        <ul>
                            <li><strong>transformation.apply()</strong>: Applies transformation matrix to bulk coordinates. Performs rigid body transformation on all atom coordinates simultaneously, efficiently transforming ligand coordinates to align with protein template structure.</li>
                            <li><strong>Point3D</strong>: RDKit coordinate setting for individual atoms. Sets transformed coordinates for each atom in the ligand conformer, ensuring accurate positioning relative to the protein template structure.</li>
                            <li><strong>validate_template_molecule()</strong>: Validates template molecule quality and properties. Checks for required properties like "ca_rmsd" and "template_pid", ensuring template molecules meet quality standards for reliable pose prediction.</li>
                            <li><strong>enhance_template_with_metadata()</strong>: Adds comprehensive metadata to transformed ligands. Sets properties including ca_rmsd, template_pid, similarity_score, ref_chains, mob_chains, alignment_method, and anchor_count for downstream analysis and quality assessment.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>File Path Functions</h3>
                        <ul>
                            <li><strong>pdb_path()</strong>: Finds protein PDB file in standard directory structure. Searches multiple common locations including PDBBind refined-set and other-PL directories, converting PDB ID to lowercase for filesystem compatibility. Returns path or None if not found.</li>
                            <li><strong>ligand_path()</strong>: Finds ligand file for given PDB ID in standard locations. Searches common ligand file patterns including SDF files in PDBBind directories and standalone ligand files. Handles various naming conventions and directory structures.</li>
                            <li><strong>load_template_molecules_standardized()</strong>: Loads template molecules using standardized approach with shared caching. Uses load_molecules_with_shared_cache() for efficient loading, creates lookup dictionary for fast template access, and supports SMILES exclusion for target molecules.</li>
                        </ul>
                    </div>
                    
                    <div class="function-card">
                        <h3>Advanced Features</h3>
                        <ul>
                            <li><strong>Multi-Level Fallback Strategy</strong>: Four progressive alignment methods (homologous → sequence → 3Di → centroid) ensuring robust alignment across diverse protein structures. Each level has specific quality controls and fallback conditions for maximum reliability.</li>
                            <li><strong>Progressive CA RMSD Thresholds</strong>: Quality control with primary threshold (10Å) and fallback thresholds (15Å, 20Å) ensuring template availability while maintaining quality standards. Central atom final fallback when all thresholds fail.</li>
                            <li><strong>Chain Selection Validation</strong>: Validates binding site chains from embedding data with fallback to all available chains. Ensures sufficient CA atoms for alignment and provides detailed logging of chain selection decisions.</li>
                            <li><strong>Bond Length Validation</strong>: Comprehensive molecular geometry validation ensuring reasonable bond lengths (0.5-3.0Å range) after coordinate transformation. Prevents molecular distortion and ensures chemical reasonableness of transformed structures.</li>
                        </ul>
                    </div>
                </div>
                
                <div id="workflow" class="workflow-features">
                    <h3>Workflow Features & Quality Control</h3>
                    <ul>
                        <li><strong>Multi-Level Fallback Strategy</strong>: Four progressive alignment methods (homologous → sequence → 3Di → centroid) with specific quality controls for each level, ensuring robust alignment across diverse protein structures</li>
                        <li><strong>Progressive CA RMSD Thresholds</strong>: Quality control with primary threshold (10Å) and fallback thresholds (15Å, 20Å) ensuring template availability while maintaining quality standards</li>
                        <li><strong>Chain Selection Validation</strong>: Validates binding site chains from embedding data with fallback to all available chains, ensuring sufficient CA atoms for alignment</li>
                        <li><strong>Bond Length Validation</strong>: Comprehensive molecular geometry validation ensuring reasonable bond lengths (0.5-3.0Å range) after coordinate transformation</li>
                        <li><strong>Metadata Tracking</strong>: Records alignment method, RMSD, anchor count, and chain information for downstream analysis and quality assessment</li>
                        <li><strong>Error Handling</strong>: Comprehensive error handling with detailed logging for debugging alignment and transformation failures</li>
                        <li><strong>File Path Management</strong>: Robust file path handling with multiple search locations and filesystem compatibility for various data organization schemes</li>
                    </ul>
                </div>
                
                <div id="legend" class="color-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <span>Start/End Points</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span>Process Steps</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f39c12;"></div>
                        <span>Decision Points</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9b59b6;"></div>
                        <span>Alignment Operations</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e67e22;"></div>
                        <span>Transformation Steps</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #34495e;"></div>
                        <span>Validation</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span>Fallback/Error</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis',
                nodeSpacing: 60,
                rankSpacing: 60
            }
        });
    </script>
</body>
</html> 